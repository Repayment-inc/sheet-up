# エージェント運用ルール

> **最重要**: 作業開始前に必ず `OBSIDIAN.md` を参照し、最新ルール・資料構成を把握すること。

## AGENTS

- 実装前に Obsidian MCP から `30_Apps/Sheet Up/REQUIREMENTS.md`、`30_Apps/Sheet Up/PROGRESS.md` を確認し、方針とディレクトリ構成に沿って作業する。
- セクションや機能を追加・変更した場合は、同ドキュメントを必ず更新し最新状態を保つ。
- 既にソースコードがあり、それがドキュメントと整合性が合わない場合は**ソースコードを正しいものとする**。
- タスクが完了したら Obsidian の `30_Apps/Sheet Up/PROGRESS.md` を確認し、該当項目のチェック状態を更新する。
- 進捗や判断メモは必要に応じてこの `AGENTS.md` に追記し、他のエージェントが状況を把握できるようにする。
- 実装が終わったら、想定コミットメッセージ（日本語）を提案すること。
- コミットとプッシュはユーザーが手作業で行う。エージェントは `git commit` や `git push` を実行しない。


## Git
このリポジトリでは、エージェントによる自動化は必ず `github` MCP サーバー経由で GitHub と連携すること。

### Issue
- Issue 作成は常に MCP サーバーの `create_issue` アクションを利用し、ローカルの `gh` や直接の API 呼び出しは禁止。
- Issue は「ひとつのユーザー操作／内部処理／検証タスク」に対応させ、実装・テスト・ドキュメントなどの個別ステップは原則分割する。
  - 例: 「ブックの CRUD」ではなく「ブック新規作成」「ブック名称変更」「ブック削除」「ブック読込（表示）」のように切り出す。
  - テスト追加やドキュメント更新も、機能実装と独立して必要に応じて別 Issue を立てる。
  - 分割が適さないと判断した場合は、統合する理由（依存関係・同時レビューが必須 等）を Issue 本文の冒頭に記載する。
- Issue のタイトルや本文、コミットメッセージ、プルリクエスト本文・タイトルは必ず日本語で記述すること。

### Branch

- 1 Issue あたり最低 1 ブランチを必ず用意し、既存ブランチに別 Issue の作業を混在させない。小さなバグ修正でも `fix/...` などの専用ブランチを切ること。

### Commit / Push

- コミットとプッシュはユーザーが手作業で実施する。エージェントは差分内容と推奨コミットメッセージを共有し、`git commit` / `git push` を実行しない。
- コミットメッセージは Conventional Commits 形式に従い、`<type>: <summary>` を基本とする。
  - サマリーは「何をしたか」ではなく「何が起きるか」を説明する。
  - 選択した TYPE に応じて、変更内容が一目で把握できる表現を心がける。
  - 良い書き方の例:
    - `docs: APIドキュメントにSSOによる認証方法を追加`
    - `fix: 変数名 userId を user_id に変更`
    - `fix: チケット#999対応 - 項目AをBに変更`
  - 避けるべき書き方の例:
    - `update README`（内容が不明）
    - `◯◯を修正した`（曖昧な表現）
    - `fix: 最大値変更`（変更内容が具体的に伝わらない）
- エージェントはコミット提案時に上記ルールに沿ったメッセージを提示する。

#### コミット TYPE 選択フロー

##### 基本的な考え方

- 上から順に確認し、最初に当てはまる TYPE を選択する。
- チームで合意したら独自の TYPE を追加するとよい。

**思想**:

- 関係するファイル（のコミット）を TYPE で集約することで、履歴参照を容易にする
- リリース自動化時の機械的判定を容易にする
- 安易に `fix` / `feat` / `chore` を選択しないようにする

##### revert

**使用条件**: 特定のコミットの変更を取り消す場合

- `git revert` の結果をそのままコミットする（余計な変更を追加しない）
- 基本的に自動生成されるため、手動での使用頻度は低い
- 高頻度で使用する場合は開発フローの見直しを検討すること

##### build

**使用条件**: ビルドプロセスに関係する変更

**対象ファイル**:

- Make、Taskfile 等のビルドタスクファイル
- ビルド用のシェルスクリプト
- ビルドプロセスから参照される設定ファイル
- **注意**: ワークフローファイル（`.github/workflows/` 等）は含めない → `ci` を使用

##### test

**使用条件**: テスト用のファイルの変更

**重要な注意点**:

- 「作業的な意味でのテスト」としての使用は **禁止**
- ユニットテストコードの扱いは要検討（本体コードとセットであるべき）

**判断基準**:

- ユニットテスト以外のテストコード（E2E、統合テスト等）
- テスト関連ファイルを集約することで参照性が向上する場合
- コード本体とユニットテストを別コミットで PR を出したい場合など

##### ci

**使用条件**: CI/CD に関係する変更

**対象ファイル**:

- GitHub Actions 等のワークフローファイル
- CI/CD 用の設定ファイル
- デプロイメント関連スクリプト
- `.github/` ディレクトリ配下はすべて `ci` とすると判断が楽

##### style

**使用条件**: フォーマッター・リンターによる機械的な変更

**対象ファイル**:

- Prettier、ESLint 等の自動修正結果
- 変更されたフォーマット設定の適用
- 古いファイルへの現行設定の適用
- 基本的に **機械的な変更のみ** に限定する
- 後で参照する価値が低い（参照不要と判断できるようにすると後々楽）

##### refactor

**使用条件**: 外部仕様を変えない内部構造の改善

**定義**: `ソフトウェアの外部から見た動作を変えずに、コードの内部構造を改善する作業`

**対象例**:

- プライベート変数の変数名変更
- コードフォーマット（機械的でない改行・スペース調整）
- Terraform のリソース名変更（ `moved` ブロック使用で plan 差分なし）

**注意**:

- この変更で問題を発生させてはならない。参照不要になるよう使用を限定することを推奨
- プライベートメソッドのシグネチャ変更（影響範囲が大きい）
- 動作に影響する可能性がある変更

##### perf

**使用条件**: パフォーマンス改善に特化した変更

**対象例**:

- 明らかに低速なアルゴリズムの高速化
- メモリ使用量の最適化
- 計算量の改善

**注意**:

- 日常的にパフォーマンス修正が必要な状況は設計を見直すべき
- 早期リターンの追加等は慎重に判断（バグの温床になる可能性）

##### docs

**使用条件**: ドキュメント（コメント含む）の変更

**対象**:

- README、API ドキュメント等の更新
- コメントの修正・追加
- タイポ（誤字・脱字）の修正
- 人が読むもので、コードの動作に影響しない変更

##### fix

**使用条件**: バグの修正

**対象**:

- 明確なバグフィックス
- 仕様変更への対応（要チーム判断）

**注意**:

- 「期待している状態への変更」は `feat` との境界が曖昧
- 設定値の変更等、仕様変更はバグではないことに留意
- 可能な限りバグフィックスのみに限定することを推奨

##### feat

**使用条件**: 新機能・仕様の追加

**対象**:

- 新しいメソッド・関数の追加
- 新しいファイル・モジュールの追加
- 既存機能の拡張
- 機能の削除（仕様変更の一種）

**例**:

- Terraform でのリソース追加
- API エンドポイントの追加
- 新しい設定オプションの追加

##### chore

**使用条件**: 上記のいずれにも当てはまらない変更

**使用例**:

- 複数の軽微な修正が混在（TYPO 修正 + コメント修正 + フォーマット調整等）
- 依存関係の更新
- 設定ファイルの軽微な調整
- 基本的に後で参照不要な内容になるべき

**注意**:

- できるだけ使用を避け、適切な TYPE に分類する
- 必要なら新しい TYPE を追加することを検討する

##### まとめ

###### 優先順位

1. **リリース自動化**: 機械的な TYPE 判定を容易にする
2. **履歴参照性**: 読み飛ばしやすく、検索しやすい履歴を作る
3. **コミット品質向上**: `update xxx file` や `add xxx` のような無意味なタイトルを削減
- プルリクエストの作成や更新も MCP サーバー（例: `create_pull_request`, `update_pull_request`）を通じて行い、直接の操作は禁止。
- MCP を使えなかった場合など、ルールから外れる対応を取ったときは、プルリクエスト本文に理由を必ず記録すること。


### 作業開始前のチェック
- `main` を最新状態に更新する（`git fetch` → fast-forward）。
- 変更を加える前に必ず派生ブランチを作成し、ブランチ名と作業内容の整合を確認する。
- ブランチ削除・履歴書き換えなどの破壊的操作を実行する際は、削除前にバックアップ用ブランチを作成するか、`git reflog` で復旧可能であることを確認する。
- MCP 以外の手段で git 操作を行う場合は、必ず事前にユーザーへ報告し、理由と対処を記録する。

### 変更適用前のセルフチェック
- 実装完了後は必ず `git diff` で差分を確認し、意図しない大量削除やバイナリ化（Base64 文字列など）が含まれていないかチェックする。
- 変更ファイルは保存後に `cat` や `python3 - <<'PY' ... PY` などで再表示し、内容が期待どおりか二重確認する。
- 型チェックや `bun x tsc --noEmit` など、可能な範囲の自動テストを実行し、結果を記録する。

### ブランチ運用
- 既定ブランチは `main`。安定版として扱い、レビュー完了または自己確認済みの変更のみマージする。
- 作業開始時は `main` から派生ブランチを作成し、ブランチ名は `種類/概要` 形式とする（例: `feature/json-io`, `bugfix/sidebar-drag`, `chore/update-deps`）。
- 別 Issue の修正を同じブランチで続けて行わない。既存ブランチで未マージの変更がある場合は、必要に応じてクリーンなブランチを作り直す。
- 大規模機能やリリース準備が必要な場合は、必要に応じて `release/vX.Y` ブランチを切り、検証完了後に `main` へマージする。
- ブランチへの直接 push を避け、PR マージで取り込む。緊急修正で直接 push した場合は、理由を PR または記録に残す。

### プルリクエスト
- すべての作業ブランチは GitHub PR を経て `main` にマージする。開発者が一人でも PR を作成し、変更内容・動作確認・残課題を記載する。
- PR 作成時は本文に `Closes #123` のような形式で対応する Issue を明記し、自動クローズさせる。対応する Issue が存在しない場合は新規作成を促す。
- PR タイトルと本文は日本語。タイトルは「`feat: ...`」などコミットと同様の形式に揃える。
- PR 本文は以下を盛り込み、半年後でも状況が理解できる内容にする:
  - 変更した理由と、達成したい状態（コードの具体的な差分はレビューで確認できる前提）。
  - 背景となった課題や要求。
  - 関連するチケット番号・Issue 番号、関連ドキュメントへのリンク。
  - 将来の参考になる技術的な判断根拠。
  - 本文から 1 ホップでレビューに必要な情報へアクセスできるリンクや説明。
  - 主要な変更点（箇条書き可）、動作確認やテスト結果、残課題やフォローアップ（あれば）。
- 避けるべき記述:
  - テンプレートの不要部分の残置。
  - 「軽微な修正」など曖昧な説明。
  - 本文を空にすること。
- マージ時は Squash merge を推奨。複数コミットを保持したい場合のみ Merge commit を選択する。

### タグ・リリース
- リリースのタイミングで `vX.Y.Z` 形式（Semantic Versioning）で Git タグを付与する。
- タグを打つ際は、対応する PR やリリースノートを残して変更点をまとめる。
- 重要なマイルストーンも同様にタグ管理し、どのブランチ／コミットが基点かを明示する。

ワークフローが変わった際には、本ファイルを更新して最新のルールを共有すること。

## obsidian
このリポジトリでは、Obsidianに資料を残す際は、`obsidian_tools` MCP サーバー経由で Obsidian と連携すること。

### プロジェクトのルール及び各種資料
**必ず`OBSIDIAN.md` を参照、把握すること**
